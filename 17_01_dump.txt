Структура проекта

webplaner/
├── backend
│   ├── services
│   │   └── hash_utils.py
│   ├── uploads
│   │   └── 696b037077e549e971a6e53d
│   │       …
│   ├── config.py
│   ├── database.py
│   ├── main.py
│   ├── models.py
│   ├── requirements.txt
│   └── test.py
├── frontend
│   ├── src
│   │   …
│   ├── static
│   │   └── style.css
│   ├── templates
│   │   ├── base.html
│   │   ├── login.html
│   │   ├── register.html
│   │   ├── task_create.html
│   │   ├── task_edit.html
│   │   ├── task_form.html
│   │   ├── tasks.html
│   │   └── tasks_all.html
│   ├── app.py
│   └── requirements.txt
└── readme.md

backend/config.py

import os
from dotenv import load_dotenv
load_dotenv()


from pymongo import MongoClient

MONGO_URI = os.getenv("MONGO_URI")
DB_NAME = 'webplanner'
from pymongo import MongoClient

db = MongoClient(MONGO_URI)
db.admin.command("ping")
print("MongoDB OK")
db_client = db[DB_NAME]


=====

backend/database.py

# mongo_demo.py
from pymongo import MongoClient
from pymongo.errors import ServerSelectionTimeoutError
import uuid

from bson import ObjectId
from bson.errors import InvalidId

from datetime import datetime, timedelta

def _dt_now_iso() -> str:
    return datetime.utcnow().isoformat()


from services import hash_utils
MONGO_URI = "mongodb://localhost:27017"
DB_NAME = "demo_db"
COLL_NAME = "tasks"


class DBManager:
    def __init__(self, client):
        self.client = client
        self.users = client['users']
        self.tasks = client['tasks']
        self.files = client["files"]

    # ----------------- ЮЗЕРЫ -------------
    def create_user(self, username, password):
        if self.get_user(username) is not None:
            return None

        password_hash = hash_utils.hash_password(password)
        res = self.users.insert_one({
            "username": username,
            "password_hash": password_hash,
            "tasks": [],
            "token": ""
        })
        return str(res.inserted_id)

    def get_user(self, username):
        return self.users.find_one({"username": username})
    def get_user_by_token(self, token: str):
        return self.users.find_one({"token": token})
    def delete_user(self, username):
        return self.users.delete_one({"username": username})

    def update_user_token(self, username):
        token = str(uuid.uuid4())
        result = self.users.update_one({"username": username}, {"$set": {"token": token}})

        if result.matched_count != 1:
            return {"ok": False, "error": "User not found"}

        return {"ok": True, "token": token}
    # -------------------------------


    # --------- ТАСКИ ----------
    def create_task(self, user_id: str, task_data: dict) -> str:
        doc = dict(task_data)

        # Привязка к пользователю
        doc["user_id"] = user_id

        # Поля по умолчанию
        doc.setdefault("done", False)
        doc.setdefault("created_at", _dt_now_iso())
        doc.setdefault("updated_at", _dt_now_iso())

        res = self.tasks.insert_one(doc)
        return str(res.inserted_id)

    def edit_task(self, user_id: str, task_id: str, updates: dict) -> dict:
        """
        Редактирует задачу ТОЛЬКО если она принадлежит user_id.
        updates — поля, которые нужно обновить (например title/priority/due_date/...).

        Возвращает JSON-совместимый результат.
        """
        try:
            oid = ObjectId(task_id)
        except (InvalidId, TypeError):
            return {"ok": False, "error": "Invalid task_id"}

        # Нельзя менять владельца
        updates.pop("user_id", None)
        updates.pop("_id", None)

        # Авто-обновление updated_at
        updates["updated_at"] = _dt_now_iso()

        res = self.tasks.update_one(
            {"_id": oid, "user_id": user_id},
            {"$set": updates}
        )

        if res.matched_count == 0:
            return {"ok": False, "error": "Task not found (or not yours)"}

        return {
            "ok": True,
            "matched": res.matched_count,
            "modified": res.modified_count
        }

    def delete_task(self, user_id: str, task_id: str) -> dict:
        """
        Удаляет задачу ТОЛЬКО если она принадлежит user_id.
        Возвращает JSON-совместимый результат.
        """
        try:
            oid = ObjectId(task_id)
        except (InvalidId, TypeError):
            return {"ok": False, "error": "Invalid task_id"}

        res = self.tasks.delete_one({"_id": oid, "user_id": user_id})

        if res.deleted_count == 0:
            return {"ok": False, "error": "Task not found (or not yours)"}

        return {"ok": True, "deleted": res.deleted_count}


    def _serialize_task(self, doc: dict) -> dict:
        """Сделать документ JSON-совместимым."""
        d = dict(doc)
        if "_id" in d:
            d["_id"] = str(d["_id"])
        for k in ("due_date", "created_at", "updated_at"):
            if isinstance(d.get(k), datetime):
                d[k] = d[k].isoformat()
        return d
    def get_tasks_view(self, user_id: str, view: str, date_str: str) -> list[dict]:
        """
        view: day | week | month | year
        date_str: 'YYYY-MM-DD'
        Возвращает список задач пользователя, у которых due_date попадает в выбранный диапазон.
        """
        try:
            base = datetime.strptime(date_str, "%Y-%m-%d")  # 00:00:00
        except ValueError:
            # неправильная дата
            return []

        view = (view or "day").lower()

        if view == "day":
            start = base
            end = base + timedelta(days=1)

        elif view == "week":
            # неделя с понедельника
            start = base - timedelta(days=base.weekday())
            end = start + timedelta(days=7)

        elif view == "month":
            start = base.replace(day=1)
            if start.month == 12:
                end = start.replace(year=start.year + 1, month=1)
            else:
                end = start.replace(month=start.month + 1)

        elif view == "year":
            start = base.replace(month=1, day=1)
            end = start.replace(year=start.year + 1)

        else:
            # неизвестный view
            return []

        query = {
            "user_id": user_id,
            "due_date": {"$gte": start, "$lt": end}
        }

        docs = list(self.tasks.find(query).sort("due_date", 1))
        return [self._serialize_task(d) for d in docs]
    # -----------------------

    # -------- САБТАСКИ --------
    def add_subtask(self, user_id: str, task_id: str, title: str) -> dict:
        try:
            oid = ObjectId(task_id)
        except (InvalidId, TypeError):
            return {"ok": False, "error": "Invalid task_id"}

        sub = {"subtask_id": str(uuid.uuid4()), "title": title, "done": False}

        res = self.tasks.update_one(
            {"_id": oid, "user_id": user_id},
            {"$push": {"subtasks": sub}, "$set": {"updated_at": _dt_now_iso()}}
        )
        if res.matched_count == 0:
            return {"ok": False, "error": "Task not found (or not yours)"}

        return {"ok": True, "subtask_id": sub["subtask_id"]}

    def edit_subtask(self, user_id: str, task_id: str, subtask_id: str, updates: dict) -> dict:
        try:
            oid = ObjectId(task_id)
        except (InvalidId, TypeError):
            return {"ok": False, "error": "Invalid task_id"}

        set_fields = {}
        if "title" in updates and updates["title"] is not None:
            set_fields["subtasks.$[s].title"] = updates["title"]
        if "done" in updates and updates["done"] is not None:
            set_fields["subtasks.$[s].done"] = updates["done"]

        if not set_fields:
            return {"ok": False, "error": "No fields to update"}

        set_fields["updated_at"] = _dt_now_iso()

        res = self.tasks.update_one(
            {"_id": oid, "user_id": user_id},
            {"$set": set_fields},
            array_filters=[{"s.subtask_id": subtask_id}]
        )

        if res.matched_count == 0:
            return {"ok": False, "error": "Task not found (or not yours)"}
        if res.modified_count == 0:
            return {"ok": False, "error": "Subtask not found"}

        return {"ok": True, "modified": res.modified_count}

    def delete_subtask(self, user_id: str, task_id: str, subtask_id: str) -> dict:
        try:
            oid = ObjectId(task_id)
        except (InvalidId, TypeError):
            return {"ok": False, "error": "Invalid task_id"}

        res = self.tasks.update_one(
            {"_id": oid, "user_id": user_id},
            {"$pull": {"subtasks": {"subtask_id": subtask_id}}, "$set": {"updated_at": _dt_now_iso()}}
        )

        if res.matched_count == 0:
            return {"ok": False, "error": "Task not found (or not yours)"}
        if res.modified_count == 0:
            return {"ok": False, "error": "Subtask not found"}

        return {"ok": True}
    # --------------------------
    # ------- ФАЙЛЫ -------------
    def create_file_record(self, user_id: str, meta: dict) -> str:
        """
        meta: {file_id, filename, path, content_type, size_bytes, created_at}
        """
        doc = dict(meta)
        doc["user_id"] = user_id
        res = self.files.insert_one(doc)
        return doc["file_id"]  # возвращаем uuid, не InsertOneResult

    def get_file_record(self, user_id: str, file_id: str) -> dict | None:
        return self.files.find_one({"user_id": user_id, "file_id": file_id})

    def delete_file_record(self, user_id: str, file_id: str) -> bool:
        res = self.files.delete_one({"user_id": user_id, "file_id": file_id})
        return res.deleted_count == 1
    # ------------------------

=====

backend/main.py

# main.py
from fastapi import FastAPI, UploadFile, File, Query
from fastapi.responses import FileResponse

from database import DBManager, _dt_now_iso

from config import db_client
import models

from services import hash_utils
from fastapi import Query


import os
import uuid
import shutil
from pathlib import Path


app = FastAPI(title="Mini FastAPI")
UPLOADS_DIR = Path("uploads")
UPLOADS_DIR.mkdir(parents=True, exist_ok=True)


db = DBManager(db_client)

@app.get("/")
def root():
    return {"message": "Hello from FastAPI"}

@app.get("/health")
def ping():
    return {"status": "ok"}


@app.post("/registration")
def registration(payload: models.user_auth):
    inserted_id = db.create_user(payload.username, payload.password)
    if inserted_id is None:
        return {"error": "User already exists"}
    return {"inserted_id": inserted_id}


@app.post("/login")
def login(payload: models.user_auth):
    user = db.get_user(payload.username)
    if user is None:
        return {"ok": False, "error": "User not found"}

    is_authed = hash_utils.check_password(
        password=payload.password,
        stored_hash=user["password_hash"]
    )
    if not is_authed:
        return {"ok": False, "error": "Incorrect password"}

    return db.update_user_token(user["username"])


@app.post("/tasks")
def create_task(payload: models.TaskCreate, user_token: str):
    user = db.get_user_by_token(user_token)
    if user == None: return {"result": "User token is incorrect"}

    task_id = db.create_task(user_id=str(user["_id"]), task_data=payload.model_dump())
    return {"task_id": task_id}


@app.patch("/tasks/{task_id}")
def edit_task(task_id: str, payload: models.TaskUpdate, user_token: str):
    user = db.get_user_by_token(user_token)
    if user is None:
        return {"result": "User token is incorrect"}

    updates = payload.model_dump(exclude_unset=True)

    if not updates:
        return {"result": "No fields to update"}

    result = db.edit_task(user_id=str(user["_id"]), task_id=task_id, updates=updates)

    if not result.get("ok"):
        return {"result": result.get("error", "Edit failed")}

    return {"result": True, "modified": result.get("modified", 0)}


@app.delete("/tasks/{task_id}")
def delete_task(task_id: str, user_token: str):
    user = db.get_user_by_token(user_token)
    if user is None:
        return {"result": "User token is incorrect"}

    result = db.delete_task(user_id=str(user["_id"]), task_id=task_id)

    if not result.get("ok"):
        return {"result": result.get("error", "Delete failed")}

    return {"result": True, "deleted": result.get("deleted", 0)}


@app.get("/api/tasks")
def api_tasks(
    view: str = Query("day", pattern="^(day|week|month|year)$"),
    date: str = Query(..., pattern=r"^\d{4}-\d{2}-\d{2}$"),
    user_token: str = Query(...)
):
    user = db.get_user_by_token(user_token)
    if user is None:
        return {"result": "User token is incorrect"}

    tasks = db.get_tasks_view(user_id=str(user["_id"]), view=view, date_str=date)
    return {"result": True, "view": view, "date": date, "tasks": tasks}



@app.post("/tasks/{task_id}/subtasks")
def add_subtask(task_id: str, payload: models.SubTaskCreate, user_token: str = Query(...)):
    user = db.get_user_by_token(user_token)
    if user is None:
        return {"result": "User token is incorrect"}

    r = db.add_subtask(user_id=str(user["_id"]), task_id=task_id, title=payload.title)
    if not r.get("ok"):
        return {"result": r.get("error")}
    return {"result": True, "subtask_id": r["subtask_id"]}


@app.patch("/tasks/{task_id}/subtasks/{subtask_id}")
def edit_subtask(task_id: str, subtask_id: str, payload: models.SubTaskUpdate, user_token: str = Query(...)):
    user = db.get_user_by_token(user_token)
    if user is None:
        return {"result": "User token is incorrect"}

    updates = payload.model_dump(exclude_unset=True)
    r = db.edit_subtask(user_id=str(user["_id"]), task_id=task_id, subtask_id=subtask_id, updates=updates)
    if not r.get("ok"):
        return {"result": r.get("error")}
    return {"result": True}


@app.delete("/tasks/{task_id}/subtasks/{subtask_id}")
def delete_subtask(task_id: str, subtask_id: str, user_token: str = Query(...)):
    user = db.get_user_by_token(user_token)
    if user is None:
        return {"result": "User token is incorrect"}

    r = db.delete_subtask(user_id=str(user["_id"]), task_id=task_id, subtask_id=subtask_id)
    if not r.get("ok"):
        return {"result": r.get("error")}
    return {"result": True}


# --------------------- ФАЙЛЫ ----------------------------
@app.post("/api/files")
def upload_file(user_token: str = Query(...), file: UploadFile = File(...)):
    user = db.get_user_by_token(user_token)
    if user is None:
        return {"result": "User token is incorrect"}

    file_id = str(uuid.uuid4())

    # Папка пользователя: uploads/<user_id>/
    user_dir = UPLOADS_DIR / str(user["_id"])
    user_dir.mkdir(parents=True, exist_ok=True)

    # Безопасное имя файла (минимальная чистка)
    original_name = file.filename or "file"
    safe_name = os.path.basename(original_name).replace("\\", "_").replace("/", "_")

    # Сохраняем как: <uuid>__<original>
    disk_name = f"{file_id}__{safe_name}"
    disk_path = user_dir / disk_name

    # Пишем на диск
    size_bytes = 0
    with disk_path.open("wb") as out:
        # копируем поток
        shutil.copyfileobj(file.file, out)

    try:
        size_bytes = disk_path.stat().st_size
    except Exception:
        size_bytes = None

    meta = {
        "file_id": file_id,
        "filename": safe_name,
        "path": str(disk_path),
        "content_type": file.content_type,
        "size_bytes": size_bytes,
        "created_at": _dt_now_iso(),
    }
    db.create_file_record(user_id=str(user["_id"]), meta=meta)

    # url — наша ручка скачивания
    url = f"/api/files/{file_id}"

    return {
        "result": True,
        "attachment": {
            "file_id": file_id,
            "filename": safe_name,
            "url": url,
            "content_type": file.content_type,
            "size_bytes": size_bytes,
        }
    }



@app.get("/api/files/{file_id}")
def download_file(file_id: str, user_token: str = Query(...)):
    user = db.get_user_by_token(user_token)
    if user is None:
        return {"result": "User token is incorrect"}

    rec = db.get_file_record(user_id=str(user["_id"]), file_id=file_id)
    if rec is None:
        return {"result": "File not found"}

    path = rec.get("path")
    filename = rec.get("filename", "file")

    if not path or not os.path.exists(path):
        return {"result": "File missing on disk"}

    # FileResponse отдаёт файл как скачивание
    return FileResponse(path, filename=filename, media_type=rec.get("content_type") or "application/octet-stream")

@app.delete("/api/files/{file_id}")
def delete_file(file_id: str, user_token: str = Query(...)):
    user = db.get_user_by_token(user_token)
    if user is None:
        return {"result": "User token is incorrect"}

    rec = db.get_file_record(user_id=str(user["_id"]), file_id=file_id)
    if rec is None:
        return {"result": "File not found"}

    path = rec.get("path")
    if path and os.path.exists(path):
        os.remove(path)

    db.delete_file_record(user_id=str(user["_id"]), file_id=file_id)
    db.tasks.update_many(
        {"user_id": str(user["_id"]), "attachment.file_id": file_id},
        {"$set": {"attachment": None}}
    )
    return {"result": True}

=====

backend/models.py

from pydantic import BaseModel, Field
from typing import Optional, List
from datetime import datetime
import uuid

class user_auth(BaseModel):
    username: str
    password: str

class SubTask(BaseModel):
    subtask_id: str = Field(default_factory=lambda: str(uuid.uuid4()))
    title: str
    done: bool = False

class SubTaskCreate(BaseModel):
    title: str

class SubTaskUpdate(BaseModel):
    title: Optional[str] = None
    done: Optional[bool] = None

class Attachment(BaseModel):
    file_id: str
    filename: str
    url: str
    content_type: Optional[str] = None
    size_bytes: Optional[int] = None


class TaskCreate(BaseModel):
    title: str = Field(..., min_length=1, max_length=200)
    priority: int = Field(3, ge=1, le=5)
    due_date: Optional[datetime] = None # дата закінчення (ISO-формат краще), наприклад "2026-01-20T18:00:00"
    description: Optional[str] = Field(None, max_length=5000)
    tags: List[str] = Field(default_factory=list)
    comment: Optional[str] = Field(None, max_length=2000) # коментар до задачі
    subtasks: List[SubTask] = Field(default_factory=list) # список підзадач (якщо порожній — задача “кінцева”)
    attachment: Optional[Attachment] = None # прикріплений файл (метаінфа)

class TaskUpdate(BaseModel):
    title: Optional[str] = Field(None, min_length=1, max_length=200)
    priority: Optional[int] = Field(None, ge=1, le=5)
    due_date: Optional[datetime] = None
    description: Optional[str] = Field(None, max_length=5000)
    tags: Optional[List[str]] = None
    comment: Optional[str] = Field(None, max_length=2000)
    subtasks: Optional[List[SubTask]] = None
    attachment: Optional[Attachment] = None
    done: Optional[bool] = None

=====

backend/requirements.txt

annotated-doc==0.0.4
annotated-types==0.7.0
anyio==4.12.1
exceptiongroup==1.3.1
fastapi==0.128.0
idna==3.11
pydantic==2.12.5
pydantic_core==2.41.5
starlette==0.50.0
typing-inspection==0.4.2
typing_extensions==4.15.0

=====

backend/services/hash_utils.py

import hashlib

def hash_password(password: str) -> str:
    return hashlib.sha256(password.encode()).hexdigest()

def check_password(password: str, stored_hash: str) -> bool:
    return hash_password(password) == stored_hash

=====

backend/test.py

import json
import sys
import urllib.parse
import urllib.request
import urllib.error
from getpass import getpass
from datetime import datetime

DEFAULT_BASE_URL = "http://127.0.0.1:8000"


def request_json(method: str, url: str, payload: dict | None = None, timeout: int = 10) -> tuple[int, dict]:
    """
    Делает HTTP запрос (POST/PATCH/DELETE/GET) с JSON телом (если нужно).
    Возвращает (status_code, dict). Если ответ не JSON -> {"raw": "..."}.
    """
    data = None
    headers = {}

    if payload is not None:
        data = json.dumps(payload).encode("utf-8")
        headers["Content-Type"] = "application/json"

    req = urllib.request.Request(url, data=data, headers=headers, method=method)

    try:
        with urllib.request.urlopen(req, timeout=timeout) as resp:
            body = resp.read().decode("utf-8", errors="replace")
            try:
                return resp.status, json.loads(body)
            except json.JSONDecodeError:
                return resp.status, {"raw": body}

    except urllib.error.HTTPError as e:
        body = e.read().decode("utf-8", errors="replace")
        try:
            return e.code, json.loads(body)
        except json.JSONDecodeError:
            return e.code, {"raw": body}

    except Exception as e:
        return 0, {"error": str(e)}


def input_nonempty(prompt: str) -> str:
    while True:
        s = input(prompt).strip()
        if s:
            return s
        print("Пусто. Попробуй ещё раз.")


def input_optional(prompt: str) -> str | None:
    s = input(prompt).strip()
    return s if s else None


def input_int(prompt: str, default: int, min_v: int, max_v: int) -> int:
    s = input(prompt).strip()
    if not s:
        return default
    try:
        v = int(s)
        if v < min_v or v > max_v:
            raise ValueError
        return v
    except ValueError:
        print(f"Нужно число {min_v}..{max_v}. Взял по умолчанию: {default}")
        return default


def parse_due_date(s: str | None) -> str | None:
    """
    Принимает:
      - None / пусто -> None
      - "YYYY-MM-DD" -> "YYYY-MM-DDT00:00:00"
      - "YYYY-MM-DD HH:MM" -> "YYYY-MM-DDTHH:MM:00"
      - "YYYY-MM-DDTHH:MM:SS" -> как есть
    Возвращает ISO строку или None.
    """
    if not s:
        return None

    s = s.strip()

    # Уже ISO?
    try:
        dt = datetime.fromisoformat(s)
        return dt.isoformat()
    except ValueError:
        pass

    # YYYY-MM-DD
    try:
        dt = datetime.strptime(s, "%Y-%m-%d")
        return dt.isoformat()
    except ValueError:
        pass

    # YYYY-MM-DD HH:MM
    try:
        dt = datetime.strptime(s, "%Y-%m-%d %H:%M")
        return dt.isoformat()
    except ValueError:
        pass

    print("Не смог распарсить due_date. Примеры: 2026-01-20 или 2026-01-20 18:30")
    return None


def ensure_logged_in(state: dict) -> bool:
    if not state.get("token"):
        print("❌ Сначала войди в аккаунт (пункт 2).")
        return False
    return True


def action_register(state: dict):
    print("\n=== Регистрация ===")
    username = input_nonempty("Username: ")
    password = getpass("Password: ")

    status, data = request_json("POST", f"{state['base_url']}/registration", {"username": username, "password": password})
    print(f"HTTP: {status}")
    print("Ответ:", data)


def action_login(state: dict):
    print("\n=== Вход ===")
    username = input_nonempty("Username: ")
    password = getpass("Password: ")

    status, data = request_json("POST", f"{state['base_url']}/login", {"username": username, "password": password})
    print(f"HTTP: {status}")
    print("Ответ:", data)

    # Совместимо с:
    # {"ok": true, "token": "..."} или {"result": true, "token": "..."}
    ok = False
    if isinstance(data, dict) and "token" in data:
        if data.get("ok") is True or data.get("result") is True:
            ok = True

    if status == 200 and ok:
        state["user"] = username
        state["token"] = data["token"]
        print(f"✅ Успешный вход как: {username}")
        print("Token:", state["token"])
    else:
        state["user"] = None
        state["token"] = None
        print("❌ Вход не выполнен.")
        if isinstance(data, dict) and data.get("error"):
            print("Причина:", data["error"])
        elif isinstance(data, dict) and isinstance(data.get("result"), str):
            print("Причина:", data["result"])


def action_whoami(state: dict):
    user = state.get("user")
    token = state.get("token")
    if user and token:
        print(f"Ты вошёл как: {user}")
        print(f"Token: {token}")
    else:
        print("Ты не вошёл в аккаунт.")


def action_set_url(state: dict):
    url = input_nonempty("Новый BASE_URL (например http://127.0.0.1:8000): ")
    state["base_url"] = url.rstrip("/")
    print("BASE_URL установлен:", state["base_url"])


def action_create_task(state: dict):
    print("\n=== Создать таску ===")
    if not ensure_logged_in(state):
        return

    title = input_nonempty("Title: ")
    priority = input_int("Priority (1..5, default 3): ", default=3, min_v=1, max_v=5)
    due_raw = input_optional("Due date (YYYY-MM-DD или YYYY-MM-DD HH:MM) [enter = пусто]: ")
    due_date = parse_due_date(due_raw)
    description = input_optional("Description [enter = пусто]: ")
    comment = input_optional("Comment [enter = пусто]: ")
    tags_raw = input_optional("Tags через пробел (например #study #work) [enter = пусто]: ")
    tags = tags_raw.split() if tags_raw else []

    subtasks = []
    add_sub = input_optional("Добавить подзадачи? (y/n) [enter = n]: ")
    if add_sub and add_sub.lower().startswith("y"):
        while True:
            st = input_optional("  Subtask title [enter = закончить]: ")
            if not st:
                break
            subtasks.append({"title": st, "done": False})

    payload = {
        "title": title,
        "priority": priority,
        "due_date": due_date,
        "description": description,
        "tags": tags,
        "comment": comment,
        "subtasks": subtasks,
        "attachment": None,
    }

    url = f"{state['base_url']}/tasks?{urllib.parse.urlencode({'user_token': state['token']})}"
    status, data = request_json("POST", url, payload)
    print(f"HTTP: {status}")
    print("Ответ:", data)

    # если сервер вернул task_id — покажем
    if isinstance(data, dict) and data.get("task_id"):
        print("✅ Task ID:", data["task_id"])


def action_edit_task(state: dict):
    print("\n=== Редактировать таску (PATCH) ===")
    if not ensure_logged_in(state):
        return

    task_id = input_nonempty("Task ID: ")

    print("Оставь поле пустым, если не хочешь менять.")
    title = input_optional("New title: ")
    prio_raw = input_optional("New priority (1..5): ")
    due_raw = input_optional("New due_date (YYYY-MM-DD или YYYY-MM-DD HH:MM): ")
    desc = input_optional("New description: ")
    comment = input_optional("New comment: ")
    tags_raw = input_optional("New tags через пробел (например #a #b): ")
    done_raw = input_optional("Done? (true/false): ")

    updates = {}

    if title is not None:
        updates["title"] = title

    if prio_raw is not None:
        try:
            p = int(prio_raw)
            if 1 <= p <= 5:
                updates["priority"] = p
            else:
                print("priority вне 1..5 — пропускаю")
        except ValueError:
            print("priority не число — пропускаю")

    if due_raw is not None:
        updates["due_date"] = parse_due_date(due_raw)

    if desc is not None:
        updates["description"] = desc

    if comment is not None:
        updates["comment"] = comment

    if tags_raw is not None:
        updates["tags"] = tags_raw.split() if tags_raw else []

    if done_raw is not None:
        v = done_raw.strip().lower()
        if v in ("true", "1", "yes", "y"):
            updates["done"] = True
        elif v in ("false", "0", "no", "n"):
            updates["done"] = False
        else:
            print("done не распознан (true/false) — пропускаю")

    if not updates:
        print("❌ Нечего обновлять.")
        return

    url = f"{state['base_url']}/tasks/{task_id}?{urllib.parse.urlencode({'user_token': state['token']})}"
    status, data = request_json("PATCH", url, updates)
    print(f"HTTP: {status}")
    print("Ответ:", data)


def action_delete_task(state: dict):
    print("\n=== Удалить таску (DELETE) ===")
    if not ensure_logged_in(state):
        return

    task_id = input_nonempty("Task ID: ")
    confirm = input_optional("Точно удалить? (y/n) [enter = n]: ")
    if not (confirm and confirm.lower().startswith("y")):
        print("Отмена.")
        return

    url = f"{state['base_url']}/tasks/{task_id}?{urllib.parse.urlencode({'user_token': state['token']})}"
    status, data = request_json("DELETE", url, payload=None)
    print(f"HTTP: {status}")
    print("Ответ:", data)


def menu():
    print("\n===== Mini CLI =====")
    print("1) Регистрация")
    print("2) Вход")
    print("3) Кто я?")
    print("4) Поменять BASE_URL")
    print("5) Создать таску")
    print("6) Редактировать таску (PATCH)")
    print("7) Удалить таску (DELETE)")
    print("0) Выход")


def main():
    state = {
        "base_url": DEFAULT_BASE_URL,
        "user": None,
        "token": None,
    }

    if len(sys.argv) >= 2:
        state["base_url"] = sys.argv[1].rstrip("/")

    print("BASE_URL:", state["base_url"])

    while True:
        menu()
        choice = input("Выбор: ").strip()

        if choice == "1":
            action_register(state)
        elif choice == "2":
            action_login(state)
        elif choice == "3":
            action_whoami(state)
        elif choice == "4":
            action_set_url(state)
        elif choice == "5":
            action_create_task(state)
        elif choice == "6":
            action_edit_task(state)
        elif choice == "7":
            action_delete_task(state)
        elif choice == "0":
            print("Пока!")
            break
        else:
            print("Не понял. Введи 0-7.")


if __name__ == "__main__":
    main()

=====

frontend/app.py

import os
from functools import wraps
from datetime import date, datetime

import requests
from flask import Flask, render_template, request, redirect, url_for, flash, session
from flask import Response
from urllib.parse import urlparse

app = Flask(__name__)
app.secret_key = os.getenv("FLASK_SECRET", "dev-secret-change-me")

BACKEND_BASE = os.getenv("BACKEND_BASE", "http://127.0.0.1:8000").rstrip("/")
TIMEOUT = 7



def backend_url(path: str) -> str:
    return BACKEND_BASE + path


def is_logged_in() -> bool:
    return bool(session.get("user_token"))


def login_required(fn):
    @wraps(fn)
    def wrapper(*args, **kwargs):
        if not is_logged_in():
            return redirect(url_for("login"))
        return fn(*args, **kwargs)
    return wrapper


@app.context_processor
def inject_user():
    return {"is_logged_in": is_logged_in(), "user": session.get("user")}


def normalize_datetime_local(dt_local: str) -> str | None:
    """input datetime-local => ISO строка с секундами (Pydantic datetime хорошо ест ISO)"""
    if not dt_local:
        return None
    try:
        dt = datetime.fromisoformat(dt_local)
        return dt.isoformat(timespec="seconds")
    except ValueError:
        return dt_local


def call_backend(method: str, path: str, *, params=None, json=None):
    """Запрос к бэку с user_token в query (как у тебя в FastAPI)."""
    params = dict(params or {})
    if is_logged_in():
        params.setdefault("user_token", session["user_token"])

    return requests.request(
        method=method,
        url=backend_url(path),
        params=params,
        json=json,
        timeout=TIMEOUT,
    )


def pick_done_from_form(prefix: str = "done") -> bool:
    """
    Для чекбокса:
      <input type="hidden" name="done" value="0">
      <input type="checkbox" name="done" value="1">
    Тогда request.form.getlist("done") = ["0"] или ["0","1"].
    """
    vals = request.form.getlist(prefix)
    return "1" in vals


def get_tasks_view(view: str, d: str) -> list[dict]:
    r = call_backend("GET", "/api/tasks", params={"view": view, "date": d})
    data = r.json() if "application/json" in r.headers.get("content-type", "") else {"raw": r.text}

    if isinstance(data, dict) and data.get("result") == "User token is incorrect":
        session.pop("user_token", None)
        flash("Сессия истекла. Войди заново.", "error")
        return []

    if isinstance(data, dict) and data.get("result") is True:
        return data.get("tasks", []) or []

    flash(f"Не удалось получить задачи: {data}", "error")
    return []


def find_task_in_list(tasks: list[dict], task_id: str) -> dict | None:
    for t in tasks:
        if t.get("_id") == task_id:
            return t
    return None


# ---------------- AUTH ----------------

@app.get("/")
def home():
    return redirect(url_for("tasks_list") if is_logged_in() else url_for("login"))


@app.get("/register")
def register():
    if is_logged_in():
        return redirect(url_for("tasks_list"))
    return render_template("register.html")


@app.post("/register")
def register_submit():
    username = request.form.get("username", "").strip()
    password = request.form.get("password", "").strip()
    if not username or not password:
        flash("Введите логин и пароль", "error")
        return redirect(url_for("register"))

    try:
        r = requests.post(backend_url("/registration"), json={"username": username, "password": password}, timeout=TIMEOUT)
        data = r.json() if "application/json" in r.headers.get("content-type", "") else {"raw": r.text}
        if isinstance(data, dict) and data.get("error"):
            flash(f"Регистрация: {data['error']}", "error")
            return redirect(url_for("register"))

        flash("Аккаунт создан ✅ Теперь войди.", "ok")
        return redirect(url_for("login"))
    except requests.RequestException as e:
        flash(f"Ошибка подключения к бэкенду: {e}", "error")
        return redirect(url_for("register"))


@app.get("/login")
def login():
    if is_logged_in():
        return redirect(url_for("tasks_list"))
    return render_template("login.html")


@app.post("/login")
def login_submit():
    username = request.form.get("username", "").strip()
    password = request.form.get("password", "").strip()
    if not username or not password:
        flash("Введите логин и пароль", "error")
        return redirect(url_for("login"))

    try:
        r = requests.post(backend_url("/login"), json={"username": username, "password": password}, timeout=TIMEOUT)
        data = r.json() if "application/json" in r.headers.get("content-type", "") else {"raw": r.text}

        # /login возвращает {"ok": True, "token": "..."} :contentReference[oaicite:3]{index=3}
        if isinstance(data, dict) and data.get("ok") is False:
            flash(f"Логин: {data.get('error', 'Ошибка')}", "error")
            return redirect(url_for("login"))

        token = data.get("token") if isinstance(data, dict) else None
        if not token:
            flash(f"Логин: бэкенд не вернул token. Ответ: {data}", "error")
            return redirect(url_for("login"))

        session["user_token"] = token
        session["user"] = {"username": username}
        flash("Вход выполнен ✅", "ok")
        return redirect(url_for("tasks_list"))

    except requests.RequestException as e:
        flash(f"Ошибка подключения к бэкенду: {e}", "error")
        return redirect(url_for("login"))


@app.get("/logout")
def logout():
    session.pop("user_token", None)
    session.pop("user", None)
    flash("Вы вышли из аккаунта", "ok")
    return redirect(url_for("login"))


# ---------------- LIST: view/day/week/month/year ----------------

@app.get("/tasks")
@login_required
def tasks_list():
    view = request.args.get("view", "day")
    d = request.args.get("date", date.today().isoformat())
    tasks = get_tasks_view(view, d)
    return render_template("tasks.html", tasks=tasks, view=view, d=d, mode="view")


# ---------------- LIST ALL (через склейку year-представлений) ----------------

@app.get("/tasks/all")
@login_required
def tasks_all():
    year_from = int(request.args.get("year_from", date.today().year - 5))
    year_to = int(request.args.get("year_to", date.today().year + 1))

    all_tasks = []
    seen = set()

    for y in range(year_from, year_to + 1):
        tasks = get_tasks_view("year", f"{y}-01-01")
        for t in tasks:
            tid = t.get("_id")
            if tid and tid not in seen:
                seen.add(tid)
                all_tasks.append(t)

    # сортировка: due_date (пустые в конец)
    def sort_key(t):
        dd = t.get("due_date")
        return (dd is None, dd or "")
    all_tasks.sort(key=sort_key)

    return render_template(
        "tasks_all.html",
        tasks=all_tasks,
        year_from=year_from,
        year_to=year_to,
        mode="all"
    )


# ---------------- CREATE TASK ----------------

@app.get("/tasks/new")
@login_required
def task_new_form():
    return render_template("task_form.html")

@app.post("/tasks/new")
@login_required
def task_new_submit():
    title = request.form.get("title", "").strip()
    if not title:
        flash("Название обязательно", "error")
        return redirect(url_for("task_new_form"))

    payload = {
        "title": title,
        "priority": int(request.form.get("priority", "3")),
        "due_date": normalize_datetime_local(request.form.get("due_date", "").strip()),
        "description": (request.form.get("description", "").strip() or None),
        "comment": (request.form.get("comment", "").strip() or None),
        "tags": [t.strip() for t in request.form.get("tags", "").split(",") if t.strip()],
        "subtasks": [
            {"title": line.strip(), "done": False}
            for line in request.form.get("subtasks", "").splitlines()
            if line.strip()
        ],
        "attachment": None,
    }

    file = request.files.get("file")
    if file and file.filename:
        try:
            payload["attachment"] = upload_file_to_backend(file)
        except Exception as e:
            flash(f"Файл не загрузился: {e}", "error")
            return redirect(url_for("task_new_form"))

    try:
        r = call_backend("POST", "/tasks", json=payload)
        data = r.json() if "application/json" in r.headers.get("content-type", "") else {"raw": r.text}
        task_id = data.get("task_id") if isinstance(data, dict) else None
        if not task_id:
            flash(f"Создание: {data}", "error")
            return redirect(url_for("task_new_form"))

        flash("Задача создана ✅", "ok")
        return redirect(url_for("tasks_list"))
    except requests.RequestException as e:
        flash(f"Ошибка запроса к бэкенду: {e}", "error")
        return redirect(url_for("task_new_form"))


# ---------------- EDIT TASK (с подтягиванием из текущего списка) ----------------

@app.get("/tasks/<task_id>/edit")
@login_required
def task_edit_form(task_id: str):
    # чтобы показать подзадачи, тянем задачу из списка (передаем view/date из списка)
    view = request.args.get("view", "day")
    d = request.args.get("date", date.today().isoformat())

    tasks = get_tasks_view(view, d)
    task = find_task_in_list(tasks, task_id)

    # fallback: если не нашли — попробуем год
    if task is None:
        tasks_y = get_tasks_view("year", f"{date.today().year}-01-01")
        task = find_task_in_list(tasks_y, task_id)

    # если всё равно не нашли — покажем пустую болванку (редактирование полей всё равно работает)
    if task is None:
        task = {"_id": task_id, "title": "", "priority": 3, "done": False, "tags": [], "subtasks": []}
        flash("Не смог найти задачу в выбранном диапазоне (возможно due_date пустая или другой период).", "error")

    return render_template("task_edit.html", task=task, view=view, d=d)

@app.post("/tasks/<task_id>/edit")
@login_required
def task_edit_submit(task_id: str):
    updates = {}

    # убрать attachment
    if request.form.get("remove_attachment") == "1":
        updates["attachment"] = None

    # заменить/добавить attachment
    file = request.files.get("file")
    if file and file.filename:
        try:
            updates["attachment"] = upload_file_to_backend(file)
        except Exception as e:
            flash(f"Файл не загрузился: {e}", "error")
            return redirect(url_for("task_edit_form", task_id=task_id))

    # дальше уже обычные поля...
    title = request.form.get("title", "").strip()
    if title:
        updates["title"] = title


    pr = request.form.get("priority", "").strip()
    if pr:
        updates["priority"] = int(pr)

    dd = normalize_datetime_local(request.form.get("due_date", "").strip())
    if dd:
        updates["due_date"] = dd

    desc = request.form.get("description", "").strip()
    if desc:
        updates["description"] = desc

    com = request.form.get("comment", "").strip()
    if com:
        updates["comment"] = com

    tags_raw = request.form.get("tags", "").strip()
    if tags_raw:
        updates["tags"] = [t.strip() for t in tags_raw.split(",") if t.strip()]

    # done чекбокс — отправляем всегда, чтобы можно было и true и false
    updates["done"] = pick_done_from_form("done")

    try:
        r = call_backend("PATCH", f"/tasks/{task_id}", json=updates)
        data = r.json() if "application/json" in r.headers.get("content-type", "") else {"raw": r.text}

        if isinstance(data, dict) and data.get("result") is True:
            flash("Сохранено ✅", "ok")
        else:
            flash(f"Редактирование: {data}", "error")

        # возвращаемся на edit с тем же view/date
        view = request.form.get("view", "day")
        d = request.form.get("date", date.today().isoformat())
        return redirect(url_for("task_edit_form", task_id=task_id, view=view, date=d))

    except requests.RequestException as e:
        flash(f"Ошибка запроса к бэкенду: {e}", "error")
        return redirect(url_for("task_edit_form", task_id=task_id))


@app.post("/tasks/<task_id>/delete")
@login_required
def task_delete(task_id: str):
    try:
        r = call_backend("DELETE", f"/tasks/{task_id}")
        data = r.json() if "application/json" in r.headers.get("content-type", "") else {"raw": r.text}

        if isinstance(data, dict) and data.get("result") is True:
            flash("Удалено ✅", "ok")
        else:
            flash(f"Удаление: {data}", "error")

        return redirect(url_for("tasks_list"))
    except requests.RequestException as e:
        flash(f"Ошибка запроса к бэкенду: {e}", "error")
        return redirect(url_for("tasks_list"))


# ---------------- SUBTASKS (+ / – / чекбоксы) ----------------

@app.post("/tasks/<task_id>/subtasks/add")
@login_required
def subtask_add(task_id: str):
    title = request.form.get("title", "").strip()
    view = request.form.get("view", "day")
    d = request.form.get("date", date.today().isoformat())

    if not title:
        flash("Подзадача: название пустое", "error")
        return redirect(url_for("task_edit_form", task_id=task_id, view=view, date=d))

    try:
        r = call_backend("POST", f"/tasks/{task_id}/subtasks", json={"title": title})
        data = r.json() if "application/json" in r.headers.get("content-type", "") else {"raw": r.text}

        if isinstance(data, dict) and data.get("result") is True:
            flash("Подзадача добавлена ✅", "ok")
        else:
            flash(f"Подзадача add: {data}", "error")

        return redirect(url_for("task_edit_form", task_id=task_id, view=view, date=d))
    except requests.RequestException as e:
        flash(f"Ошибка запроса к бэкенду: {e}", "error")
        return redirect(url_for("task_edit_form", task_id=task_id, view=view, date=d))


@app.post("/tasks/<task_id>/subtasks/<subtask_id>/edit")
@login_required
def subtask_edit(task_id: str, subtask_id: str):
    view = request.form.get("view", "day")
    d = request.form.get("date", date.today().isoformat())

    title = request.form.get("title", "").strip()
    done = pick_done_from_form("sub_done")

    updates = {"done": done}
    if title:
        updates["title"] = title

    try:
        r = call_backend("PATCH", f"/tasks/{task_id}/subtasks/{subtask_id}", json=updates)
        data = r.json() if "application/json" in r.headers.get("content-type", "") else {"raw": r.text}

        if isinstance(data, dict) and data.get("result") is True:
            flash("Подзадача сохранена ✅", "ok")
        else:
            flash(f"Подзадача edit: {data}", "error")

        return redirect(url_for("task_edit_form", task_id=task_id, view=view, date=d))
    except requests.RequestException as e:
        flash(f"Ошибка запроса к бэкенду: {e}", "error")
        return redirect(url_for("task_edit_form", task_id=task_id, view=view, date=d))


@app.post("/tasks/<task_id>/subtasks/<subtask_id>/delete")
@login_required
def subtask_delete(task_id: str, subtask_id: str):
    view = request.form.get("view", "day")
    d = request.form.get("date", date.today().isoformat())

    try:
        r = call_backend("DELETE", f"/tasks/{task_id}/subtasks/{subtask_id}")
        data = r.json() if "application/json" in r.headers.get("content-type", "") else {"raw": r.text}

        if isinstance(data, dict) and data.get("result") is True:
            flash("Подзадача удалена ✅", "ok")
        else:
            flash(f"Подзадача delete: {data}", "error")

        return redirect(url_for("task_edit_form", task_id=task_id, view=view, date=d))
    except requests.RequestException as e:
        flash(f"Ошибка запроса к бэкенду: {e}", "error")
        return redirect(url_for("task_edit_form", task_id=task_id, view=view, date=d))






def upload_file_to_backend(file_storage) -> dict:
    """
    Отправляет файл на бэкенд: POST /api/files?user_token=...
    Ожидает ответ вида: {"result": True, "attachment": {...}}
    """
    files = {
        "file": (
            file_storage.filename,
            file_storage.stream,
            file_storage.mimetype or "application/octet-stream",
        )
    }

    r = requests.post(
        backend_url("/api/files"),
        params={"user_token": session["user_token"]},
        files=files,
        timeout=TIMEOUT,
    )

    data = r.json() if "application/json" in r.headers.get("content-type", "") else {"raw": r.text}
    if not isinstance(data, dict) or data.get("result") is not True:
        raise RuntimeError(f"Upload failed: {data}")

    attachment = data.get("attachment")
    if not isinstance(attachment, dict):
        raise RuntimeError(f"No attachment in response: {data}")

    return attachment


def file_id_from_attachment(att: dict) -> str | None:
    """
    Пытается достать file_id из attachment.
    Если бэк возвращает {"file_id": "..."} — берём его.
    Иначе пытаемся распарсить из att["url"] (например /api/files/<id> или /files/<id>).
    """
    if not isinstance(att, dict):
        return None

    fid = att.get("file_id")
    if isinstance(fid, str) and fid.strip():
        return fid.strip()

    url = att.get("url")
    if not isinstance(url, str) or not url.strip():
        return None

    path = urlparse(url).path
    parts = [p for p in path.split("/") if p]
    if not parts:
        return None

    # ожидаем .../files/<id> или .../api/files/<id>
    if parts[-2:] and parts[-2] == "files":
        return parts[-1]
    if len(parts) >= 3 and parts[-3:] and parts[-2] == "files":
        return parts[-1]

    return parts[-1]  # fallback


@app.get("/files/<file_id>")
@login_required
def file_download(file_id: str):
    br = requests.get(
        backend_url(f"/api/files/{file_id}"),
        params={"user_token": session["user_token"]},
        stream=True,
        timeout=TIMEOUT,
    )

    if br.status_code >= 400:
        flash(f"Скачать не получилось: {br.status_code}", "error")
        return redirect(request.referrer or url_for("tasks_list"))

    content_type = br.headers.get("content-type", "application/octet-stream")
    content_disp = br.headers.get("content-disposition")

    def generate():
        for chunk in br.iter_content(chunk_size=8192):
            if chunk:
                yield chunk

    headers = {}
    if content_disp:
        headers["Content-Disposition"] = content_disp

    return Response(generate(), headers=headers, content_type=content_type)

@app.post("/files/<file_id>/delete")
@login_required
def file_delete(file_id: str):
    task_id = request.form.get("task_id", "").strip()

    # 1) Удаляем файл (и запись files)
    r = requests.delete(
        backend_url(f"/api/files/{file_id}"),
        params={"user_token": session["user_token"]},
        timeout=TIMEOUT,
    )
    data = r.json() if "application/json" in r.headers.get("content-type", "") else {"raw": r.text}

    if not (isinstance(data, dict) and data.get("result") is True):
        flash(f"Удаление файла: {data}", "error")
        return redirect(request.referrer or url_for("tasks_list"))

    # 2) Если знаем task_id — отвязываем файл от задачи
    if task_id:
        pr = call_backend("PATCH", f"/tasks/{task_id}", json={"attachment": None})
        pdata = pr.json() if "application/json" in pr.headers.get("content-type", "") else {"raw": pr.text}

        if isinstance(pdata, dict) and pdata.get("result") is True:
            flash("Файл удалён и откреплён ✅", "ok")
        else:
            flash(f"Файл удалён, но не открепился от задачи: {pdata}", "error")
    else:
        flash("Файл удалён ✅", "ok")

    return redirect(request.referrer or url_for("tasks_list"))



if __name__ == "__main__":
    app.jinja_env.globals.update(file_id_from_attachment=file_id_from_attachment)
    app.run(debug=True, port=5000)

=====

frontend/requirements.txt

blinker==1.9.0
click==8.3.1
colorama==0.4.6
Flask==3.1.2
itsdangerous==2.2.0
Jinja2==3.1.6
MarkupSafe==3.0.3
Werkzeug==3.1.5

=====

frontend/static/style.css

body { font-family: Arial, sans-serif; margin: 0; background: #fafafa; }
.wrap { max-width: 1100px; margin: 0 auto; padding: 16px; }

.top { display: flex; justify-content: space-between; align-items: center; padding: 10px 0; }
.brand { text-decoration: none; font-weight: bold; color: #111; }

.box { background: #fff; border: 1px solid #ddd; padding: 12px; border-radius: 6px; }
label { display: block; margin: 8px 0; }
input, textarea, select { width: 100%; padding: 8px; box-sizing: border-box; }

button, .btn { padding: 8px 12px; border: 1px solid #bbb; background: #eee; cursor: pointer; text-decoration: none; color: #111; border-radius: 4px; }
.row { display: flex; gap: 10px; align-items: center; flex-wrap: wrap; }
.space { justify-content: space-between; }

.muted { color: #666; }
.small { font-size: 12px; }

.alerts { margin: 10px 0; }
.alert { padding: 8px 10px; border-radius: 6px; margin-bottom: 6px; }
.alert.ok { background: #e7ffe7; border: 1px solid #a8e5a8; }
.alert.error { background: #ffe7e7; border: 1px solid #e5a8a8; }

.table { margin-top: 12px; border: 1px solid #ddd; border-radius: 6px; overflow: hidden; background: #fff; }
.tr { display: grid; grid-template-columns: 2.2fr .7fr 1.2fr .6fr 1.2fr 1.6fr 1fr; gap: 10px; padding: 10px; border-top: 1px solid #eee; }
.th { background: #f2f2f2; border-top: none; font-weight: bold; }
.title { font-weight: 600; }
.sublist { display: flex; flex-direction: column; gap: 8px; }
.subrow { display: flex; gap: 8px; align-items: center; }
.subtitle { flex: 1; min-width: 200px; }
.grow { flex: 1; }
a { color: #111; }
a:hover { text-decoration: underline; }

=====

frontend/templates/base.html

<!doctype html>
<html lang="ru">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>{{ title or "WebPlanner" }}</title>
  <link rel="stylesheet" href="{{ url_for('static', filename='style.css') }}">
</head>
<body>
  <div class="wrap">
    <header class="top">
      <a class="brand" href="{{ url_for('home') }}">WebPlanner</a>

      <div class="row">
        {% if is_logged_in %}
          <span class="muted small">{{ user.username if user else "" }}</span>
          <a class="btn" href="{{ url_for('tasks_list') }}">Период</a>
          <a class="btn" href="{{ url_for('tasks_all') }}">Все задачи</a>
          <a class="btn" href="{{ url_for('logout') }}">Выйти</a>
        {% else %}
          <a class="btn" href="{{ url_for('login') }}">Войти</a>
          <a class="btn" href="{{ url_for('register') }}">Регистрация</a>
        {% endif %}
      </div>
    </header>

    {% with messages = get_flashed_messages(with_categories=true) %}
      {% if messages %}
        <div class="alerts">
          {% for cat, msg in messages %}
            <div class="alert {{ cat }}">{{ msg }}</div>
          {% endfor %}
        </div>
      {% endif %}
    {% endwith %}

    <main>{% block content %}{% endblock %}</main>
  </div>
</body>
</html>

=====

frontend/templates/login.html

{% extends "base.html" %}
{% block content %}
<h2>Вход</h2>
<form class="box" method="post" action="{{ url_for('login_submit') }}">
  <label>Логин <input name="username" required></label>
  <label>Пароль <input type="password" name="password" required></label>
  <button type="submit">Войти</button>
</form>
{% endblock %}

=====

frontend/templates/register.html

{% extends "base.html" %}
{% block content %}
<h2>Регистрация</h2>
<form class="box" method="post" action="{{ url_for('register_submit') }}">
  <label>Логин <input name="username" required></label>
  <label>Пароль <input type="password" name="password" required></label>
  <button type="submit">Создать</button>
</form>
{% endblock %}

=====

frontend/templates/task_create.html

{% extends "base.html" %}
{% block content %}
<h2>Новая задача</h2>

<form class="box" method="post" action="{{ url_for('task_new_submit') }}">
  <label>Название
    <input name="title" required>
  </label>

  <label>Приоритет (1..5)
    <input name="priority" type="number" min="1" max="5" value="3">
  </label>

  <label>Срок (datetime-local, опционально)
    <input name="due_date" type="datetime-local">
  </label>

  <label>Описание (опционально)
    <textarea name="description" rows="4"></textarea>
  </label>

  <label>Теги через запятую (опционально)
    <input name="tags" placeholder="учёба, курсовая">
  </label>

  <label>Комментарий (опционально)
    <input name="comment">
  </label>

  <label>Подзадачи (каждая с новой строки, опционально)
    <textarea name="subtasks" rows="4" placeholder="Сделать верстку&#10;Подключить БД"></textarea>
  </label>

  <button type="submit">Создать</button>
  <a class="btn" href="{{ url_for('dashboard') }}">Назад</a>
</form>
{% endblock %}

=====

frontend/templates/task_edit.html

{% extends "base.html" %}
{% block content %}

<h2>Редактирование</h2>
<p class="muted small">ID: {{ task.get("_id") }}</p>

<form class="box" method="post" action="{{ url_for('task_edit_submit', task_id=task.get('_id')) }}" enctype="multipart/form-data">
  <!-- чтобы вернуться в тот же период -->
  <input type="hidden" name="view" value="{{ view }}">
  <input type="hidden" name="date" value="{{ d }}">

  <label>Название
    <input name="title" value="{{ task.get('title','') }}">
  </label>

  <label>Приоритет (1..5)
    <input name="priority" type="number" min="1" max="5" value="{{ task.get('priority',3) }}">
  </label>

  <label>Срок (ISO в списке, но редактировать можно через datetime-local)
    <input name="due_date" type="datetime-local">
    <div class="muted small">Текущий: {{ task.get("due_date") or "-" }}</div>
  </label>

  <label>Описание
    <textarea name="description" rows="4">{{ task.get('description','') }}</textarea>
  </label>

  <label>Теги (через запятую)
    <input name="tags" value="{{ (task.get('tags') or []) | join(', ') }}">
  </label>

  <label>Комментарий
    <input name="comment" value="{{ task.get('comment','') }}">
  </label>

  <label class="row">
    <!-- hidden + checkbox => можно выставлять и true и false -->
    <input type="hidden" name="done" value="0">
    <input type="checkbox" name="done" value="1" {{ "checked" if task.get("done") else "" }}>
    <span>Выполнено</span>
  </label>
  {% set att = task.get("attachment") %}
  <h3>Файл</h3>

  {% if att %}
    {% set fid = file_id_from_attachment(att) %}
    <div class="row">
      <span class="muted small">{{ att.get("filename","file") }}</span>
      {% if fid %}
        <a class="btn" href="{{ url_for('file_download', file_id=fid) }}">Скачать</a>
        <input type="hidden" name="task_id" value="{{ task.get('_id') }}">

        <button
          type="submit"
          formaction="{{ url_for('file_delete', file_id=fid) }}"
          formmethod="post"
          title="Удалить файл">
          Удалить файл
        </button>
      {% endif %}
    </div>

    <label class="row">
      <input type="checkbox" name="remove_attachment" value="1">
      <span>Убрать прикрепление из задачи (не удаляя файл)</span>
    </label>
  {% else %}
    <p class="muted">Файл не прикреплён.</p>
  {% endif %}

  <label>Загрузить новый файл (заменит текущий)
    <input type="file" name="file">
  </label>

  <button type="submit">Сохранить задачу</button>
</form>

<h3>Подзадачи</h3>

{% set subs = task.get("subtasks") or [] %}
{% if not subs %}
  <p class="muted">Подзадач нет.</p>
{% else %}
  <div class="sublist">
    {% for s in subs %}
      <div class="subrow">
        <form class="row" method="post" action="{{ url_for('subtask_edit', task_id=task.get('_id'), subtask_id=s.get('subtask_id')) }}">
          <input type="hidden" name="view" value="{{ view }}">
          <input type="hidden" name="date" value="{{ d }}">

          <input name="title" value="{{ s.get('title','') }}" class="subtitle">

          <label class="row">
            <input type="hidden" name="sub_done" value="0">
            <input type="checkbox" name="sub_done" value="1" {{ "checked" if s.get("done") else "" }}>
            <span class="muted small">done</span>
          </label>

          <button type="submit">💾</button>
        </form>

        <form method="post" action="{{ url_for('subtask_delete', task_id=task.get('_id'), subtask_id=s.get('subtask_id')) }}">
          <input type="hidden" name="view" value="{{ view }}">
          <input type="hidden" name="date" value="{{ d }}">
          <button type="submit">−</button>
        </form>
      </div>
    {% endfor %}
  </div>
{% endif %}

<form class="box row" method="post" action="{{ url_for('subtask_add', task_id=task.get('_id')) }}">
  <input type="hidden" name="view" value="{{ view }}">
  <input type="hidden" name="date" value="{{ d }}">

  <input name="title" placeholder="Новая подзадача..." class="grow">
  <button type="submit">+</button>
</form>

<div class="row" style="margin-top:12px;">
  <a class="btn" href="{{ url_for('tasks_list', view=view, date=d) }}">Назад</a>
</div>

{% endblock %}

=====

frontend/templates/task_form.html

{% extends "base.html" %}
{% block content %}
<h2>Новая задача</h2>

<form class="box" method="post" action="{{ url_for('task_new_submit') }}" enctype="multipart/form-data">
  <label>Название
    <input name="title" required>
  </label>

  <label>Приоритет (1..5)
    <input name="priority" type="number" min="1" max="5" value="3">
  </label>

  <label>Срок (опционально)
    <input name="due_date" type="datetime-local">
  </label>

  <label>Описание
    <textarea name="description" rows="4"></textarea>
  </label>

  <label>Теги (через запятую)
    <input name="tags" placeholder="учёба, курсовая">
  </label>

  <label>Комментарий
    <input name="comment">
  </label>
  <label>Файл (опционально)
    <input type="file" name="file">
  </label>
  <label>Подзадачи (каждая с новой строки)
    <textarea name="subtasks" rows="4"></textarea>
  </label>

  <button type="submit">Создать</button>
  <a class="btn" href="{{ url_for('tasks_list') }}">Назад</a>
</form>
{% endblock %}

=====

frontend/templates/tasks.html

{% extends "base.html" %}
{% block content %}

<div class="row space">
  <h2 style="margin:0;">Задачи (по периоду)</h2>
  <a class="btn" href="{{ url_for('task_new_form') }}">+ Новая</a>
</div>

<form class="box row space" method="get" action="{{ url_for('tasks_list') }}">
  <label>Вид
    <select name="view">
      <option value="day"   {{ "selected" if view=="day" else "" }}>День</option>
      <option value="week"  {{ "selected" if view=="week" else "" }}>Неделя</option>
      <option value="month" {{ "selected" if view=="month" else "" }}>Месяц</option>
      <option value="year"  {{ "selected" if view=="year" else "" }}>Год</option>
    </select>
  </label>

  <label>Дата
    <input type="date" name="date" value="{{ d }}">
  </label>

  <button type="submit">Показать</button>
</form>

{% if not tasks %}
  <p class="muted">Нет задач для выбранного периода.</p>
{% else %}
  <div class="table">
    <div class="tr th">
      <div>Название</div>
      <div>Pri</div>
      <div>Due</div>
      <div>Done</div>
      <div>Sub</div>
      <div>Теги</div>
      <div>Файл</div>
      <div>ID</div>
      <div></div>
    </div>

    {% for t in tasks %}
      {% set subs = t.get("subtasks") or [] %}
      {% set tags = t.get("tags") or [] %}
      {% set att = t.get("attachment") %}
      {% set fid = file_id_from_attachment(att) if att else None %}

      <div class="tr">
        <div class="title">{{ t.get("title","") }}</div>
        <div>{{ t.get("priority","") }}</div>
        <div class="muted small">{{ t.get("due_date","") or "-" }}</div>
        <div>{{ "✅" if t.get("done") else "—" }}</div>
        <div class="muted small">{{ subs|length }}</div>

        <div class="muted small">
          {{ ", ".join(tags) if tags else "-" }}
        </div>

        <div class="muted small">
          {% if att %}
            {% if fid %}
              <a href="{{ url_for('file_download', file_id=fid) }}">
                {{ att.get("filename","file") }}
              </a>
              <form method="post" action="{{ url_for('file_delete', file_id=fid) }}" style="display:inline;">
                <input type="hidden" name="task_id" value="{{ t.get('_id','') }}">
                <button type="submit" title="Удалить файл">x</button>
              </form>
            {% else %}
              {{ att.get("filename","file") }}
            {% endif %}
          {% else %}
            -
          {% endif %}
        </div>

        <div class="muted small">{{ t.get("_id","") }}</div>

        <div class="row">
          <a class="btn"
             href="{{ url_for('task_edit_form', task_id=t.get('_id',''), view=view, date=d) }}">Edit</a>

          <form method="post" action="{{ url_for('task_delete', task_id=t.get('_id','')) }}">
            <button type="submit">Del</button>
          </form>
        </div>
      </div>
    {% endfor %}
  </div>
{% endif %}

{% endblock %}

=====

frontend/templates/tasks_all.html

{% extends "base.html" %}
{% block content %}

<div class="row space">
  <h2 style="margin:0;">Все задачи</h2>
  <a class="btn" href="{{ url_for('task_new_form') }}">+ Новая</a>
</div>

<form class="box row space" method="get" action="{{ url_for('tasks_all') }}">
  <label>Год от
    <input type="number" name="year_from" value="{{ year_from }}" min="1970" max="2100">
  </label>
  <label>Год до
    <input type="number" name="year_to" value="{{ year_to }}" min="1970" max="2100">
  </label>
  <button type="submit">Показать</button>
</form>

{% if not tasks %}
  <p class="muted">Ничего не найдено в этом диапазоне.</p>
{% else %}
  <div class="table">
    <div class="tr th">
      <div>Название</div>
      <div>Pri</div>
      <div>Due</div>
      <div>Done</div>
      <div>Sub</div>
      <div>Теги</div>
      <div>Файл</div>
      <div>ID</div>
      <div></div>
    </div>

    {% for t in tasks %}
      {% set subs = t.get("subtasks") or [] %}
      {% set tags = t.get("tags") or [] %}
      {% set att = t.get("attachment") %}
      {% set fid = file_id_from_attachment(att) if att else None %}

      <div class="tr">
        <div class="title">{{ t.get("title","") }}</div>
        <div>{{ t.get("priority","") }}</div>
        <div class="muted small">{{ t.get("due_date","") or "-" }}</div>
        <div>{{ "✅" if t.get("done") else "—" }}</div>
        <div class="muted small">{{ subs|length }}</div>

        <div class="muted small">
          {{ ", ".join(tags) if tags else "-" }}
        </div>

        <div class="muted small">
          {% if att %}
            {% if fid %}
              <a href="{{ url_for('file_download', file_id=fid) }}">
                {{ att.get("filename","file") }}
              </a>
              <form method="post" action="{{ url_for('file_delete', file_id=fid) }}" style="display:inline;">
                <button type="submit" title="Удалить файл">x</button>
              </form>
            {% else %}
              {{ att.get("filename","file") }}
            {% endif %}
          {% else %}
            -
          {% endif %}
        </div>

        <div class="muted small">{{ t.get("_id","") }}</div>

        <div class="row">
          <a class="btn" href="{{ url_for('task_edit_form', task_id=t.get('_id','')) }}">Edit</a>

          <form method="post" action="{{ url_for('task_delete', task_id=t.get('_id','')) }}">
            <button type="submit">Del</button>
          </form>
        </div>
      </div>
    {% endfor %}
  </div>
{% endif %}

{% endblock %}

=====

readme.md



